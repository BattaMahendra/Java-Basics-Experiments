                            ğŸ§µ 2ï¸âƒ£ STACK AREA (JAVA STACK)

        What it is:
            Memory used for method execution

        Key rule (burn this in):
            ğŸ§µ One Stack per Thread

        What lives in stack frames:
            ğŸ“Œ Local variables
            ğŸ“Œ Method parameters
            ğŸ“Œ Return address
            ğŸ“Œ Partial results


ğŸ“ HOW STACK WORKS (REAL FLOW)

        void a() {
            b();
        }

        void b() {
            c();
        }

        void c() {
        }

        main(String[] args){
             a();
        }

        Execution order:
            a() â†’ b() â†’ c()

        Stack growth: LIFO
            Frame for c()
            Frame for b()
            Frame for a()
            Frame for main() method

        c() finishes     â†’ frame popped
        b() finishes     â†’ frame popped
        a() finishes     â†’ frame popped
        main() finishes  â†’ stack empty

        LIFO. Always. No exceptions.

ğŸ’¥ StackOverflowError (why it happens)

        Cause:
            â€¢ Deep recursion
            â€¢ Infinite method calls

        Not caused by:
            âŒ Heap size
            âŒ GC

        JVM tuning:
            -Xss1m  (stack size per thread)


ğŸ§  PRACTICAL STACK FACT

    Local primitives â†’ stored directly in stack
    Object references â†’ stored in stack, object in heap

    So yes:
        Changing object fields does NOT change the reference

